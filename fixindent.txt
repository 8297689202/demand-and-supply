
import streamlit as st
import streamlit_authenticator as stauth
import yaml
from yaml.loader import SafeLoader
import pandas as pd
import yfinance as yf
import datetime
from datetime import timedelta
import time
import plotly.graph_objects as go


# Set page configuration
st.set_page_config(
    page_title="Demand zone scanner for indian stock market | RBR and DBR Pattern Scanner ",
    page_icon="üîç",  # Set the app icon (can use an emoji or a path to an image)
    layout="wide",
)
hide_streamlit_style = """
            <style>
            #MainMenu {visibility: hidden;}
            footer {visibility: hidden;}
            </style>
            """
st.markdown(hide_streamlit_style, unsafe_allow_html=True)
hide_streamlit_style = """
            <style>
            #MainMenu {visibility: hidden;}
            footer {visibility: hidden;}
            </style>
            """
st.markdown(hide_streamlit_style, unsafe_allow_html=True)


# Load configuration from YAML file
with open("config.yaml") as file:
    config = yaml.load(file, Loader=SafeLoader)

# Create authenticator object
authenticator = stauth.Authenticate(
    config["credentials"],
    config["cookie"]["name"],
    config["cookie"]["key"],
    config["cookie"]["expiry_days"],
    config["preauthorized"],
)

# Render the login widget
name, authentication_status, username = authenticator.login("main")

if st.session_state["authentication_status"]:
    authenticator.logout("Logout", "main")
    st.write(f'Welcome *{st.session_state["name"]}*')
    # Function to calculate True Range (TR) and ATR
    def calculate_atr(data, length=14):
        data["previous_close"] = data["Close"].shift(1)
        data["tr1"] = abs(data["High"] - data["Low"])
        data["tr2"] = abs(data["High"] - data["previous_close"])
        data["tr3"] = abs(data["Low"] - data["previous_close"])
        data["TR"] = data[["tr1", "tr2", "tr3"]].max(axis=1)

    def rma(series, length):
        alpha = 1 / length
        return series.ewm(alpha=alpha, adjust=False).mean()

    data["ATR"] = rma(data["TR"], length).round(2)
    data["Range"] = (data["High"] - data["Low"]).round(2)
    data["Body"] = abs(data["Close"] - data["Open"]).round(2)
    return data


def capture_ohlc_data(data, i):
    """
    Captures the OHLC data for the 10 rows before and 10 rows after the third candle in the surrounded if pattern.

    Parameters:
    data (pandas.DataFrame): The DataFrame containing the OHLC data.
    i (int): The index of the first candle in the surrounded if pattern.

    Returns:
    pandas.DataFrame: The OHLC data for the 10 rows before and 10 rows after the third candle in the pattern.
    """
    # Calculate the start and end indices
    start_index = max(0, i - 10)
    end_index = min(len(data), i + 15)

    # Extract the OHLC data
    ohlc_data = data.iloc[start_index:end_index]

    return ohlc_data


def find_patterns(data, interval):
    patterns = []
    for i in range(len(data) - 1, 2, -1):
        # Calculate TR and ATR values with rounding
        tr_value_3 = round(data["TR"].iloc[i - 2], 2)
        atr_value_3 = round(data["ATR"].iloc[i - 2], 2)
        tr_value_2 = round(data["TR"].iloc[i - 1], 2)
        atr_value_2 = round(data["ATR"].iloc[i - 1], 2)
        tr_value_1 = round(data["TR"].iloc[i], 2)
        atr_value_1 = round(data["ATR"].iloc[i], 2)

        # Calculate Body and Range values
        third_candle_range = data["Range"].iloc[i - 2]
        third_candle_body_size = data["Body"].iloc[i - 2]
        second_candle_range = data["Range"].iloc[i - 1]
        second_candle_body_size = data["Body"].iloc[i - 1]
        first_candle_range = data["High"].iloc[i] - data["Close"].iloc[i - 1]
        first_candle_body_size = data["Body"].iloc[i]

        # Fourth candle calculations
        fourth_candle_open = min(data["Open"].iloc[i - 3], data["Close"].iloc[i - 3])
        fourth_candle_close = max(data["Open"].iloc[i - 3], data["Close"].iloc[i - 3])
        fourth_candle_body_size = fourth_candle_close - fourth_candle_open

        third_candle_open = min(data["Open"].iloc[i - 2], data["Close"].iloc[i - 2])
        third_candle_close = max(data["Open"].iloc[i - 2], data["Close"].iloc[i - 2])
        third_candle_body_size = third_candle_close - third_candle_open

        overlap = max(0, min(fourth_candle_close, third_candle_close)) - max(
            fourth_candle_open, third_candle_open
        )

        # Determine proximal_line and stop_loss
        if data["Body"].iloc[i - 1] > 0.50 * data["Range"].iloc[i - 1]:
            proximal_line = max(data["Open"].iloc[i - 1], data["Close"].iloc[i - 1])
        else:
            proximal_line = data["High"].iloc[i - 1]

        if data["Open"].iloc[i - 2] > data["Close"].iloc[i - 2]:
            pattern_name_is = "DBR"
            stop_loss = min(
                data["Low"].iloc[i], data["Low"].iloc[i - 1], data["Low"].iloc[i - 2]
            )
        else:
            pattern_name_is = "RBR"
            stop_loss = min(data["Low"].iloc[i], data["Low"].iloc[i - 1])

        # Find the last consecutive candle that meets the condition
        j = i
        last_candle_date = None
        while (
            j < len(data)
            and data["Close"].iloc[j] > data["Open"].iloc[j]
            and data["TR"].iloc[j] > data["ATR"].iloc[j]
            and data["Body"].iloc[j] > 0.5 * data["Range"].iloc[j]
        ):
            last_candle_date = data.index[j].strftime("%d %b %Y %H:%M:%S")
            j += 1
        if j < len(data):
            first_candle_range = data["High"].iloc[j] - data["Close"].iloc[i - 1]

        # Check condition
        if data["Open"].iloc[i - 2] > data["Close"].iloc[i - 2]:
            condition = (
                data["Open"].iloc[i] < data["Open"].iloc[i - 2]
                and tr_value_3 > atr_value_3
                and tr_value_2 < atr_value_2
                and tr_value_1 > atr_value_1
                and third_candle_range >= 2 * second_candle_range
                and first_candle_range >= 4 * second_candle_range
                and first_candle_range >= 2 * third_candle_range
                and overlap / third_candle_body_size <= 0.5
                and third_candle_body_size >= 0.5 * third_candle_range
                and second_candle_range >= 0.5 * second_candle_body_size
                and first_candle_body_size >= 0.5 * data["Range"].iloc[i]
                and (
                    round(min(data["Low"].iloc[i + 1 :])) > round(proximal_line)
                    or (
                        round(min(data["Low"].iloc[i + 1 :])) > round(stop_loss)
                        and any(
                            round(data["High"].iloc[j]) < round(proximal_line)
                            for j in range(i + 1, len(data))
                        )
                    )
                )
                and data["Open"].iloc[i]
                > max(data["Open"].iloc[i - 1], data["Close"].iloc[i - 1])
            )
        else:
            condition = (
                tr_value_3 > atr_value_3
                and tr_value_2 < atr_value_2
                and tr_value_1 > atr_value_1
                and third_candle_range >= 2 * second_candle_range
                and first_candle_range >= 4 * second_candle_range
                and first_candle_range >= 2 * third_candle_range
                and overlap / third_candle_body_size <= 0.5
                and third_candle_body_size >= 0.5 * third_candle_range
                and second_candle_range >= 0.5 * second_candle_body_size
                and first_candle_body_size >= 0.5 * data["Range"].iloc[i]
                and (
                    round(min(data["Low"].iloc[i + 1 :])) > round(proximal_line)
                    or (
                        round(min(data["Low"].iloc[i + 1 :])) > round(stop_loss)
                        and any(
                            round(data["High"].iloc[j]) < round(proximal_line)
                            for j in range(i + 1, len(data))
                        )
                    )
                )
                and data["Open"].iloc[i]
                > max(data["Open"].iloc[i - 1], data["Close"].iloc[i - 1])
            )

        if condition:
            if interval in ["1d", "1wk", "1mo", "3mo"]:
                date_3 = data.index[i - 2].strftime("%d %b %Y")
                date_2 = data.index[i - 1].strftime("%d %b %Y")
                date_1 = data.index[i].strftime("%d %b %Y")
            else:
                date_3 = data.index[i - 2].strftime("%d %b %Y %H:%M:%S")
                date_2 = data.index[i - 1].strftime("%d %b %Y %H:%M:%S")
                date_1 = data.index[i].strftime("%d %b %Y %H:%M:%S")

            time_frame = interval
            latest_closing_price = round(data["Close"].iloc[-1], 2)

            if round(min(data["Low"].iloc[i + 1 :])) > round(proximal_line):
                zone_distance = (
                    (latest_closing_price - proximal_line) / proximal_line * 100
                )
            else:
                if round(min(data["Low"].iloc[i + 1 :])) < round(stop_loss) and any(
                    round(data["High"].iloc[j]) < round(proximal_line)
                    for j in range(i + 1, len(data))
                ):
                    zone_distance = 0

            ohlc_data = capture_ohlc_data(data, i)

            patterns.append(
                {
                    "date_3": date_3,
                    "date_1": date_1,
                    "Proximal_line": proximal_line,
                    "Distal_line": stop_loss,
                    "Eod_close": latest_closing_price,
                    "Pattern_name": pattern_name_is,
                    "Time_frame": time_frame,
                    "zone_distance": zone_distance,
                    "OHLC_data": ohlc_data,
                }
            )

    return patterns


def plot_candlestick(
    symbol,
    legin_date,
    legout_date,
    Proximal_line,
    Distal_line,
    time_frame,
    pattern_name,
    eod_close,
):
    try:
        for j, pattern in enumerate(patterns):
            ohlc_data = pattern["OHLC_data"]

            stock_data = []
            annotations = []

            # Determine date format based on time_frame
            date_format = (
                "%Y-%m-%d"
                if time_frame in ["1d", "1wk", "1mo", "3mo"]
                else "%Y-%m-%d %H:%M:%S"
            )

            # Collect data and create annotations
            for index, row in ohlc_data.iterrows():
                formatted_date = index.strftime(date_format)
                stock_data.append(
                    {
                        "time": formatted_date,
                        "open": row["Open"],
                        "high": row["High"],
                        "low": row["Low"],
                        "close": row["Close"],
                    }
                )

                if index == ohlc_data.index[8]:
                    annotations.append(
                        {
                            "x": formatted_date,
                            "y": row["High"],
                            "text": f"legin datetime <br> {formatted_date}",
                            "showarrow": True,
                            "arrowhead": 2,
                            "arrowsize": 1,
                            "arrowwidth": 2,
                            "arrowcolor": "blue",
                            "ax": -20,
                            "ay": -30,
                            "font": dict(size=12, color="black"),
                            "bgcolor": "rgba(255, 255, 0, 0.5)",  # light yellow
                        }
                    )
                elif index == ohlc_data.index[10]:
                    annotations.append(
                        {
                            "x": formatted_date,
                            "y": row["High"],
                            "text": f"legout datetime <br> {formatted_date}",
                            "showarrow": True,
                            "arrowhead": 2,
                            "arrowsize": 1,
                            "arrowwidth": 2,
                            "arrowcolor": "blue",
                            "ax": -20,
                            "ay": -30,
                            "font": dict(size=12, color="black"),
                            "bgcolor": "rgba(255, 255, 0, 0.5)",  # light yellow
                        }
                    )

            fig = go.Figure(
                data=[
                    go.Candlestick(
                        x=[item["time"] for item in stock_data],
                        open=[item["open"] for item in stock_data],
                        high=[item["high"] for item in stock_data],
                        low=[item["low"] for item in stock_data],
                        close=[item["close"] for item in stock_data],
                        increasing_line_color="#26a69a",
                        decreasing_line_color="#ef5350",
                        increasing_fillcolor="#26a69a",
                        decreasing_fillcolor="#ef5350",
                        line_width=0.5,
                    )
                ]
            )

            # Add annotations
            fig.update_layout(annotations=annotations)

            # Determine high and low prices dynamically
            index_9 = ohlc_data.index[9]
            open_9 = ohlc_data.loc[index_9, "Open"]
            close_9 = ohlc_data.loc[index_9, "Close"]
            high_9 = ohlc_data.loc[index_9, "High"]
            low_9 = ohlc_data.loc[index_9, "Low"]

            if abs(open_9 - close_9) > 0.50 * (high_9 - low_9):
                high_price = max(open_9, close_9)
            else:
                high_price = high_9

            if (
                ohlc_data.loc[ohlc_data.index[8], "Open"]
                > ohlc_data.loc[ohlc_data.index[8], "Close"]
            ):
                low_price = min(
                    ohlc_data.loc[ohlc_data.index[8], "Low"],
                    low_9,
                    ohlc_data.loc[ohlc_data.index[10], "Low"],
                )
            else:
                low_price = min(low_9, ohlc_data.loc[ohlc_data.index[10], "Low"])
            total_risk = high_price - low_price
            minimum_target = (total_risk * 5) + high_price

            # Add rectangular shape
            shape_start = ohlc_data.index[8].strftime(date_format)
            shape_end = ohlc_data.index[-1].strftime(date_format)

            fig.add_shape(
                type="rect",
                xref="x",
                yref="y",
                x0=shape_start,
                y0=low_price,
                x1=shape_end,
                y1=high_price,
                fillcolor="green",
                opacity=0.2,
                layer="below",
                line=dict(width=0),
            )

            specified_index = ohlc_data.index[17].strftime(date_format)

            fig.add_annotation(
                x=specified_index,
                y=high_price,
                text=f"{ticker} entry at: {high_price}",
                showarrow=False,
                xref="x",
                yref="y",
                font=dict(size=12, color="black"),
                align="center",
                valign="bottom",
                yshift=10,
            )

            fig.add_annotation(
                x=specified_index,
                y=low_price,
                text=f"Stoploss at : {low_price}",
                showarrow=False,
                xref="x",
                yref="y",
                font=dict(size=12, color="black"),
                align="center",
                valign="top",
                yshift=-10,
            )

            # Add annotation for minimum_target with background color
            fig.add_annotation(
                x=ohlc_data.index[-1].strftime(date_format),
                y=minimum_target,
                text=f"<b>1:5 Target: {minimum_target:.2f}</b>",
                showarrow=True,
                arrowhead=2,
                arrowsize=1,
                arrowwidth=2,
                arrowcolor="red",
                ax=-20,
                ay=-30,
                font=dict(size=12, color="black"),
                bgcolor="rgba(0, 255, 0, 0.3)",  # Light green background for entry price
            )

            # Custom tick labels with line breaks
            custom_ticks = [item["time"].replace(" ", "<br>") for item in stock_data]

            fig.update_layout(
                xaxis_showgrid=False,
                xaxis_rangeslider_visible=False,
                xaxis=dict(
                    type="category",
                    ticktext=custom_ticks,
                    tickvals=[item["time"] for item in stock_data],
                    tickangle=0,
                    tickmode="array",
                    tickfont=dict(size=10),
                ),
                autosize=True,
                margin=dict(l=0, r=0, t=100, b=40),
                legend=dict(x=0, y=1.0),
                font=dict(size=12),
                height=600,
                width=800,
                dragmode=False,  # Disable drag mode
                paper_bgcolor="white",
                plot_bgcolor="white",
                xaxis_fixedrange=True,  # Disable zooming on x-axis
                yaxis_fixedrange=True,  # Disable zooming on y-axis
            )

            # Add styled HTML text annotation with all the provided arguments
            header_text = (
                f"<span style='padding-right: 20px;'><b>üìä Chart:</b> {symbol}</span>"
                f"<span style='padding-right: 20px;'><b>üïí Close:</b> ‚Çπ {eod_close}</span>"
                f"<span style='padding-right: 20px;'><b>üü¢ Zone:</b> {pattern_name}</span>"
                f"<span><b>‚è≥ Time frame:</b> {time_frame}</span>"
            )

            fig.add_annotation(
                x=0.5,
                y=1.20,
                text=header_text,
                showarrow=False,
                align="center",
                xref="paper",
                yref="paper",
                font=dict(size=17, color="white"),
                bgcolor="rgba(0, 0, 0, 0.8)",
                borderpad=4,
                width=800,
                height=50,
                valign="middle",
            )
            return fig

    except Exception as e:
        st.error(f"Error occurred while fetching data for {symbol}: {e}")


st.markdown(
    "<h1 style='text-align: center;'> Welcome to demand zone scanner </h2>",
    unsafe_allow_html=True,
)

st.markdown(
    "<img src='https://yt3.googleusercontent.com/OfYP3wK5_zJVC8xSogqLBU9MzCDuzitraf3vc8L9hrecWZvRX8wo5hqgel_eQyhS_Z7jbp881x8=s160-c-k-c0x00ffffff-no-rj' width='200' style='display: block; margin: 0 auto;'>",
    unsafe_allow_html=True,
)

st.markdown(
    """
<div style='background-color: #E8F2FC; padding: 10px; border-radius: 5px;'>
    Remember - "Making money in the stock market is as easy as making a cup of tea but <strong>your trade should be process oriented not profit oriented.</strong>" <br> <span>- Dr. Ravi R Kumar
</div>
""",
    unsafe_allow_html=True,
)

st.markdown("<h5 style='text-align: center;'>Try scannerüëá</h5>", unsafe_allow_html=True)

st.write(
    "To also make finding demand zone as easy as making a cup of tea. and don't forget to join our telegram [channel](https://t.me/dr_ravi_r_kumar_course_notes)."
)
st.markdown("___________")

# Get user input for tickers
ticker_option = st.radio(
    "Select ticker option:",
    ["Custom Symbol", "Nifty50stocks", "Bhavcopy Stocks"],
    horizontal=True,
)

if ticker_option == "Custom Symbol":
    user_tickers = st.text_input("Enter tickers (comma-separated):", "")
    tickers = [ticker.strip() for ticker in user_tickers.split(",")]
elif ticker_option == "Bhavcopy Stocks":
    hot_stocks = [
        "INFY",
        "MPHASIS",
        "ASTRAL",
        "ITC",
        "INDIACEM",
        "ASIANPAINT",
        "BERGEPAINT",
        "LALPATHLAB",
        "COROMANDEL",
        "AUBANK",
        "HCLTECH",
        "COLPAL",
        "GLENMARK",
        "TITAN",
    ]

    tickers = st.multiselect("Select hot stocks:", hot_stocks, default=hot_stocks)
else:
    predefined_tickers = [
        "ADANIPORTS",
        "APOLLOHOSP",
        "ASIANPAINT",
        "AXISBANK",
        "BAJAJ-AUTO",
        "BAJFINANCE",
        "BAJAJFINSV",
        "BPCL",
    ]
    tickers = st.multiselect(
        "Select predefined tickers:", predefined_tickers, default=predefined_tickers
    )

# Get user input for interval
valid_intervals = ["1m", "5m", "15m", "30m", "1h", "2h", "1d", "1wk", "1mo", "3mo"]
interval = st.selectbox(
    "Select interval:", valid_intervals, index=valid_intervals.index("2h")
)

# Set the default period based on the selected interval
if interval in ["1m"]:
    period = "7d"
elif interval in ["5m", "15m", "30m"]:
    period = "1mo"
elif interval in ["1h"]:
    period = "2y"
elif interval == "2h":
    period = "1y"
else:
    period = "2y"

# Create an empty DataFrame to store the patterns
patterns_df = pd.DataFrame(
    columns=[
        "Ticker",
        "Eod_close",
        "zone_distance",
        "Legin_date",
        "Legout_date",
        "Proximal_line",
        "Distal_line",
        "Pattern_name",
        "Time_frame",
    ]
)

# Add a button to scan for patterns
find_patterns_button = st.button("üîç Scan Demand Zone")
chart_figures = []
zone_distances = []  # Create a list to store zone distances

if find_patterns_button:
    patterns_found_button_clicked = True
    progress_bar = st.progress(0)
    progress_text = st.empty()
    progress_percent = 0
    start_time = time.time()
    patterns_found = []
    any_patterns_found = False  # Initialize the flag

    for i, ticker in enumerate(tickers):
        progress_percent = (i + 1) / len(tickers)
        progress_bar.progress(progress_percent)
        # Example with styled text (if supported)
        progress_text.text(
            f"üîç Scanning Demand Zone {i + 1} of {len(tickers)} - {progress_percent * 100:.2f}% Complete"
        )

        if interval == "2h":
            # Download data from 'Yahoo! Finance' using yfinance
            df = yf.download(
                ticker + ".NS", period=period, interval="1h", progress=False
            )
            if df.empty:
                st.warning(f"Invalid ticker: {ticker}")
                continue  # Skip to the next ticker

            df = df.round(2)

            # Convert the index to datetime format with hours, minutes, and seconds
            df.index = pd.to_datetime(df.index, format="%Y-%m-%d %H:%M:%S")

            # Reset the index to create a date column
            df.reset_index(inplace=True)

            # Rename the date column to 'Date'
            df.rename(columns={"index": "Date"}, inplace=True)

            # Resample the data to 2h interval, starting from 09:15:00
            df_agg = df.groupby(
                pd.Grouper(
                    key="Datetime", freq="2H", origin="2024-07-12 09:15:00+05:30"
                )
            ).agg(
                {
                    "Open": "first",
                    "High": "max",
                    "Low": "min",
                    "Close": "last",
                    "Adj Close": "last",
                }
            )

            # Remove the NaN rows
            df_final = df_agg.dropna(how="all")

            # Label the dataframe columns
            df_final.columns = ["Open", "High", "Low", "Close", "Adj Close"]
            data = df_final.copy()  # Create a copy of the DataFrame
            data = calculate_atr(data)
            patterns = find_patterns(data, interval)

        elif interval in ["1m", "5m", "15m", "30m"]:
            data = yf.download(
                ticker + ".NS", period=period, interval=interval, progress=False
            )
            if data.empty:
                st.warning(f"Invalid ticker: {ticker}")
                continue  # Skip to the next ticker
            data = data.round(2)
            data = calculate_atr(data)
            patterns = find_patterns(data, interval)

        elif interval in ["1h"]:
            data = yf.download(
                ticker + ".NS", period=period, interval=interval, progress=False
            )
            if data.empty:
                st.warning(f"Invalid ticker: {ticker}")
            data = data.round(2)
            data = calculate_atr(data)
            patterns = find_patterns(data, interval)

        else:
            data = yf.download(
                ticker + ".NS", period=period, interval=interval, progress=False
            )
            if data.empty:
                st.warning(f"Invalid ticker: {ticker}")
            data = data.round(2)
            data = calculate_atr(data)
            patterns = find_patterns(data, interval)

        if patterns:
            any_patterns_found = True  # Set the flag if patterns are found

            for pattern in patterns:
                # Collect the chart figure instead of plotting directly
                fig = plot_candlestick(
                    ticker,
                    pd.to_datetime(pattern["date_3"]),
                    pd.to_datetime(pattern["date_1"]),
                    pattern["Proximal_line"],
                    pattern["Distal_line"],
                    pattern["Time_frame"],
                    pattern["Pattern_name"],
                    pattern["Eod_close"],
                )
                chart_figures.append(fig)  # Store the figure in the list
                zone_distances.append(
                    pattern["zone_distance"]
                )  # Store the corresponding zone distance

                # Append pattern data to patterns_df
                patterns_df = pd.concat(
                    [
                        patterns_df,
                        pd.DataFrame(
                            [
                                {
                                    "Ticker": ticker,
                                    "Eod_close": pattern["Eod_close"],
                                    "zone_distance": pattern["zone_distance"],
                                    "Legin_date": pattern["date_3"],
                                    "Legout_date": pattern["date_1"],
                                    "Proximal_line": pattern["Proximal_line"],
                                    "Distal_line": pattern["Distal_line"],
                                    "Pattern_name": pattern["Pattern_name"],
                                    "Time_frame": pattern["Time_frame"],
                                }
                            ]
                        ),
                    ],
                    ignore_index=True,
                )

    patterns_df = patterns_df.sort_values(by="zone_distance", ascending=True)

    patterns_df["zone_distance"] = patterns_df["zone_distance"].apply(
        lambda x: f"{x:.2f}%" if isinstance(x, (int, float)) else x
    )
    # Reset the index
    patterns_df = patterns_df.reset_index(drop=True)

    sorted_figures = sorted(zip(zone_distances, chart_figures), key=lambda x: x[0])

    # Extract sorted figures
    sorted_chart_figures = [fig for _, fig in sorted_figures]

    progress_bar.empty()
    progress_text.empty()

    if any_patterns_found:
        st.success(
            "Scanning is complete. Below is the table data and chart view of stocks that match Ravi R. Kumar's Zone Validation rules."
        )
        # Create tabs for displaying data and charts
        tab1, tab2 = st.tabs(["üìÅ Data", "üìà Chart"])

        with tab1:
            st.markdown("**Table View**")
            st.dataframe(patterns_df, use_container_width=True, hide_index=True)

        with tab2:
            st.markdown("**Chart View**")
            for fig in sorted_chart_figures:
                st.plotly_chart(fig, use_container_width=False)
    else:
        if len(tickers) > 0 and any(
            ticker
            for ticker in tickers
            if not yf.download(
                ticker + ".NS", period=period, interval=interval, progress=False
            ).empty
        ):
            st.warning(
                "When validating the demand zone pattern for the given time frame interval, we didn't find any Rally Boring Rally or Drop Boring Rally pattern that fulfills these Ravi R Kumar zone validation rules:\n"
                "1. The boring candle to leg-in candle ratio should be 1:2, and the boring candle to leg-out candle ratio should be 1:4. This means 'one two ka four' should be their.\n"
                "2. The leg-in candle TR should be greater than the boring candle TR, which should be less than ATR, and the leg-out candle TR should be greater than its ATR.\n"
                "3. There should be a white area in the zone.\n"
                "4. The candle body behind the leg-in candle should not cover more than 50% of the leg-in candle; when checking these parameters, the zone becomes invalid.\n"
                "5. Leg-out candle formation - In the Drop Boring Rally pattern, the leg-out candle opening should not be greater than the leg-in candle opening.\n\n"
                "Dr. Ravi R Kumar says he has 14 zone validation rules. If any zone passes these basic zone validations, then you don't need to check other parameters. As per our analysis, no zone was fulfilling the basic validation rules."
            )


elif st.session_state["authentication_status"] == False:
    st.error("Username/password is incorrect")
elif st.session_state["authentication_status"] == None:
    st.warning("Please enter your username and password")
